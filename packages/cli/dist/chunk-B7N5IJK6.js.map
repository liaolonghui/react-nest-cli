{"version":3,"sources":["../src/commands/base/initComponent.ts"],"sourcesContent":["import { type Command } from 'commander';\nimport consola from 'consola';\nimport fs from 'node:fs';\nimport path from 'node:path';\nimport { cwd } from 'node:process';\nimport ora from 'ora';\nimport prompts from 'prompts';\n\n\nconst firstCharUpperCase = (str: string) => {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n// 确保目录存在\nconst ensureDir = (dir: string) => {\n    return new Promise((resolve) => {\n        fs.mkdir(dir, { recursive: true }, (err) => {\n            if (err) {\n                consola.error(`创建目录 ${dir} 失败`)\n                resolve(false)\n            } else {\n                resolve(true)\n            }\n        })\n    })\n}\n\n// 检查路径是否存在\nconst existsPath = (path: string) => {\n    return new Promise((resolve) => {\n        fs.stat(path, (err) => {\n            // consola.log(err)\n            if (err) {\n                resolve(false)\n            } else {\n                resolve(true)\n            }\n        })\n    });\n}\n\n\nconst safeSaveFile = async (path: string, content: string, force: boolean = false) => {\n    return new Promise((resolve, reject) => {\n        existsPath(path).then(exists => {\n            if (exists) {\n                if (!force) {\n                    consola.error(`文件${path} 已存在`)\n                    reject(false)\n                    return;\n                }\n            } else {\n                fs.writeFile(path, content, 'utf-8', (err) => {\n                    if (err) {\n                        consola.error(`文件${path} 写入失败`)\n                        reject(false)\n                    } else {\n                        resolve(true)\n                    }\n                })\n            }\n        }).catch(() => {\n            reject(false)\n        })\n    })\n}\n\nconst initComponent = (program: Command) => {\n    program\n        .command('init:component')\n        .alias('init:c')\n        .alias('init:comp')\n        .argument('[component-name]', '组件名称(如Button、Text、Card)')\n        .description('初始化React组件 TSX + CSS')\n        .option('-d, --dir <dir>', '生成组件目录，默认src/components', 'src/components')\n        .option('-s, --style <style>', '使用哪种样式方案，默认css', 'css')\n        .option('-j, --jsx', '是否使用JSX文件，默认TSX', false)\n        .option('-f, --force', '是否强制覆盖已存在组件', false)\n        .action(async (componentName, rest) => {\n            let { dir, style, jsx, force } = rest || {}\n            if (!componentName) {\n                const response = await prompts({\n                    type: 'text',\n                    initial: 'Button', // 默认值\n                    name: 'componentName',\n                    message: '请输入组件名称',\n                })\n                componentName = response.componentName;\n            }\n            if (!componentName || !componentName.trim()) {\n                process.stderr.write('组件名称不能为空\\n')\n                process.exit(1)\n            }\n\n            componentName = firstCharUpperCase(componentName);\n\n            // 组件目录\n            const inputComponentDir = path.join('apps/components', componentName)\n            const outputComponentDir = path.resolve(cwd(), dir, componentName)\n\n            const inputExists = await existsPath(inputComponentDir);\n            // consola.log(inputExists)\n            if (!inputExists) {\n                consola.error(`组件 ${componentName} 不存在`)\n                process.exit(1)\n            }\n\n            const tip = `初始化组件 ${componentName}`;\n            const spinner = ora(tip).start()\n\n            // 初始化组件   确保输出组件目录存在\n            const dirExists = await ensureDir(outputComponentDir);\n            if (!dirExists) {\n                spinner.fail(`组件 ${componentName} 初始化失败, 目录 ${outputComponentDir} 创建失败`)\n                return;\n            }\n\n            let esFileExt = 'tsx';\n            let styleFileExt = 'css';\n            if (jsx) {\n                esFileExt = 'jsx';\n            }\n            if (style === 'less') {\n                styleFileExt = 'less';\n            }\n\n            const esPath = path.resolve(outputComponentDir, `index.${esFileExt}`);\n            const stylePath = path.resolve(outputComponentDir, `index.${styleFileExt}`);\n            let esContent = fs.readFileSync(path.resolve(inputComponentDir, `index.${esFileExt}`), 'utf-8');\n            const styleContent = fs.readFileSync(path.resolve(inputComponentDir, `index.${styleFileExt}`), 'utf-8');\n            // 需要手动给esContent导入对应的style文件\n            esContent = `import './index.${styleFileExt}';\\n${esContent}`\n\n            Promise.all([\n                safeSaveFile(esPath, esContent, force),\n                safeSaveFile(stylePath, styleContent, force),\n            ]).then(() => {\n                spinner.succeed(`组件 ${componentName} 初始化成功, 目录 ${outputComponentDir}`)\n            }).catch(() => {\n                spinner.fail(`组件 ${componentName} 初始化失败`)\n            })\n        })\n}\n\nexport default initComponent\n"],"mappings":"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","names":["path"]}